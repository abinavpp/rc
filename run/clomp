#! /bin/bash

this=`basename $0`

unbundle_host_ir="host.ll"
unbundle_dev_ir="dev.ll"

dev_lk="dev.lk"

dev_obj="dev.o"
linked_dev_obj="dev_linked.o"
host_obj="host.o"

offload_wrapper_bitcode="offload_wrapper.bc"

run=$1
omp_common="-fopenmp -I /home/abinav/llvm_dev/build/main/projects/openmp/runtime/src"

function dump_x86_dev_lk() {
  dev_out="$1"
  cat > $dev_lk <<EOT
/*
       OpenMP Offload Linker Script
 *** Automatically generated by Clang ***
*/
TARGET(binary)
INPUT($dev_out)
SECTIONS
{
  .omp_offloading.x86_64-pc-linux-gnu :
  ALIGN(0x10)
  {
    PROVIDE_HIDDEN(.omp_offloading.img_start.x86_64-pc-linux-gnu = .);
    $dev_out
    PROVIDE_HIDDEN(.omp_offloading.img_end.x86_64-pc-linux-gnu = .);
  }
  .omp_offloading.entries :
  ALIGN(0x10)
  SUBALIGN(0x01)
  {
    PROVIDE_HIDDEN(.omp_offloading.entries_begin = .);
    *(.omp_offloading.entries)
    PROVIDE_HIDDEN(.omp_offloading.entries_end = .);
  }
}
INSERT BEFORE .data
EOT
}

# FIXME: We are relying on an unreliable fact the dev-ir comes first
# in the bundled-ir in most of the following APIs.

function get_unbundle_targets() {
  local ir="$1"
  local targets=$(cat "$ir" | grep "__CLANG_OFFLOAD_BUNDLE____START__" | \
    tr -s ' ' | cut -d ' ' -f 3)
  echo $targets | tr ' ' ','
}

function get_unbundle_dev_target() {
  local ir="$1"
  local targets

  IFS=',' read -r -a targets <<< $(get_unbundle_targets $ir)
  echo ${targets[0]:7} # :7 strips off the leading openmp-
}

function get_unbundle_host_target() {
  local ir="$1"
  local targets

  IFS=',' read -r -a targets <<< $(get_unbundle_targets $ir)
  echo ${targets[1]:5} # :5 strips off the leading host-
}

function unbundle_x86_ir() {
  local ir="$1"

  clang-offload-bundler --unbundle --type ll \
    --inputs="$ir" \
    --outputs=${unbundle_dev_ir},${unbundle_host_ir} \
    -targets=$(get_unbundle_targets $ir)
}

function get_clang_version() {
  clang --version | grep "clang version" | grep -o '\ [0-9]*\.' | \
    grep -o '[0-9]*'
}

function compile_bundled_x86_ir() {
  local final_ld="clang"
  if [[ $# -eq 2 ]]; then
    final_ld=$1; shift
  fi
  local ir="$1"

  unbundle_x86_ir "$ir"

  # host object
  clang $unbundle_host_ir -c -o $host_obj

  # device object
  clang -cc1 -emit-obj -fopenmp -fopenmp-is-device \
    -fopenmp-host-ir-file-path $unbundle_host_ir \
    -x ir $unbundle_dev_ir -o $dev_obj
  clang -shared -lomp $dev_obj -o $linked_dev_obj

  if [[ $(get_clang_version) -gt "9" ]]; then
    clang-offload-wrapper -target $(get_unbundle_host_target $ir) \
      -offload-targets=$(get_unbundle_dev_target $ir) -o $offload_wrapper_bitcode \
      $linked_dev_obj

    clang $offload_wrapper_bitcode -c -o $linked_dev_obj

    # final linking
    $final_ld $host_obj $linked_dev_obj $omp_common -lomp -lomptarget
    return
  fi

  # final linking
  dump_x86_dev_lk $linked_dev_obj

  # Frustratingly, the below command doesn't put -T as the last ld option, so it won't work
  clang $host_obj $omp_common -lomp -lomptarget -Wl,-T,$dev_lk -v

  local final_ld_cmd=$($final_ld $host_obj $omp_common -lomp -lomptarget -v |& "llvm###")
  # see our snp/misc to see this and more other bash headaches.
  bash -c "$final_ld_cmd -T $dev_lk"
}

function clean_iromp_leftovers() {
  rm $unbundle_host_ir $unbundle_dev_ir $host_obj $dev_obj\
    $linked_dev_obj $dev_lk $offload_wrapper_bitcode &> /dev/null
}

if [[ $this == "cluda" ]]; then
  cuda_path="$CUDA_PATH"

  [[ ! -d $cuda_path ]] && cuda_path="/usr/lib/cuda"

  # Why --cuda-gpu-arch=sm_xx is an unused option ?
  clang++  -L ${cuda_path}/lib64 -I ${cuda_path}/include -lcuda $@
  exit $?

elif [[ $this == "iromp" ]]; then
  compile_bundled_x86_ir $@
  clean_iromp_leftovers
  exit $?
fi

if [[ $run == "nv" ]]; then
  shift
  clang $omp_common -fopenmp-targets=nvptx64-nvidia-cuda -Xopenmp-target \
    -march=sm_$(nvsm) $@
else
  clang $omp_common -fopenmp-targets=x86_64-pc-linux-gnu $@
fi
